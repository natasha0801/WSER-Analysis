# -*- coding: utf-8 -*-
"""wser-predictor-categorical.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mIG-DN4jw7Zr_gawksJW-gVFLYzireAP
"""

# Commented out IPython magic to ensure Python compatibility.
######## PACKAGES AND USEFUL FUNCTIONS ########
# Import packages
# %tensorflow_version 2.x
import warnings, logging, os
logging.disable(logging.WARNING)
os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"
os.environ['TF_ENABLE_ONEDNN_OPTS'] = '0'
warnings.simplefilter(action='ignore', category=FutureWarning)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf

# Function to format times
def getHours(strTime):
    if " " in strTime:
      strTime= strTime[0:str.find(strTime," ")]
    if strTime == "nan" or "-" in strTime:
        return 30.0
    else:
        strTime = str.split(strTime,':')
        return float(strTime[0]) + float(strTime[1])/60.0 + float(strTime[2])/3600.0

######## DEFINE FEATURES AND LABELS ########

# Get user input for what type of model we want to run
print("---- SELECT MODEL TYPE ----")
print("(1) Silicon Valley Nerd: needs lots of splits up to Foresthill, but is a bit more accurate.")
print("(2) Quick-And-Dirty: needs only 3 splits up to Michigan Bluff, but may be less accurate.")
print("(3) Trail Nerd: as many splits as you have.")
modelType = int(input("Model Type: "))
if modelType == 1:                      # detailed model
  aidStationNames = ['Lyon Ridge', 'Red Star Ridge', 'Duncan Canyon', 'Robinson Flat', "Miller's Defeat", 'Dusty Corners', "Last Chance", "Devil's Thumb", "El Dorado Creek", "Michigan Bluff", "Foresthill"]
  neurons = 11
elif modelType ==2:                                   # simplified model
  aidStationNames = ['Robinson Flat', "Devil's Thumb", "Michigan Bluff"]
  neurons = 8
else:
  allAidStations = ['Lyon Ridge', 'Red Star Ridge', 'Duncan Canyon', 'Robinson Flat', "Miller's Defeat", 'Dusty Corners', "Last Chance", "Devil's Thumb", "El Dorado Creek", "Michigan Bluff", "Foresthill", "Rucky Chucky", "Auburn Lake Trails"]
  print("Select Latest Aid Station: ")
  for i in range(0, len(allAidStations)):
    print(f"({i+1}) {allAidStations[i]}")
  aidStationNames = allAidStations[0:int(input("> "))]
  neurons = 8 + np.ceil(len(aidStationNames) / 3.0).astype(int)

# Define features and labels
features = np.concatenate([['Gender', 'Age', 'MinTemp', 'MaxTemp'], aidStationNames])
labels=['Buckle']

######## LOAD TRAINING AND TESTING DATA ########

# Temperature data
temps = {
    2024: [94, 63],
    2023: [80, 51],
    2022: [97, 70],
    2021: [101, 73],
    2020: [93, 66],
    2019: [83, 57],
    2018: [98, 61],
    2017: [95, 75],
    2016: [93, 60],
    2015: [91, 73],
    2014: [89, 59],
    2013: [102, 73],
    2012: [71, 51],
    2011: [82, 60],
    2010: [91, 66]
}

# Define time ranges for available data
startTrain = 2016
endTrain = 2023
testYear = 2022

# Populate training dataframe
df_individual = []
for year in range(startTrain,endTrain+1):
  if year != testYear and year != 2020:
    df = pd.read_csv(f'wser{year}.csv')
    df['MaxTemp'] = temps[year][0]
    df['MinTemp'] = temps[year][1]
    df_individual.append(df)
df_train = pd.concat(df_individual)

# Populate test dataframe
df_test = pd.read_csv(f'wser{testYear}.csv')
df_test['MaxTemp'] = temps[year][0]
df_test['MinTemp'] = temps[year][1]

# Format everything as an int/float
relevantSplits = np.concatenate([aidStationNames, ["Time"]])
df_train['Gender'] = df_train['Gender'].apply(lambda x: 1.0 if x == 'M' else 0.0)
df_test['Gender'] = df_test['Gender'].apply(lambda x: 1.0 if x == 'M' else 0.0)
for i in range(0, len(relevantSplits)):
    df_train[relevantSplits[i]] = df_train[relevantSplits[i]].apply(lambda x: getHours(str(x)))
    df_test[relevantSplits[i]] = df_test[relevantSplits[i]].apply(lambda x: getHours(str(x)))

# Input data (features) in desired format
input_train = df_train[features].copy().to_numpy(dtype=float)
input_test = df_test[features].copy().to_numpy(dtype=float)

# Output data (labels) in desired format
buckleNames = ['silver', 'bronze', 'no buckle'];
silver = 24
bronze = 30
output_train = df_train["Time"].apply(lambda x: np.where([x < silver, silver <= x and x < bronze, x >= bronze])[0]).astype(int)
output_test= df_test['Time'].apply(lambda x: np.where([x < silver, silver <= x and x < bronze, x >= bronze])[0]).astype(int)
output_train = output_train.copy().to_numpy(dtype=int)
output_test = output_test.copy().to_numpy(dtype=int)

######## BUILD AND COMPILE MODEL ########
model = tf.keras.Sequential([
    tf.keras.layers.Dense(neurons, activation='relu'),
    tf.keras.layers.Dense(3)
])
model.compile(optimizer='adam',
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])

######## TRAIN MODEL ########

# Train
print("Training model...")
num_epochs=40
model.fit(input_train, output_train, epochs=num_epochs)

# Evaluate accuracy
test_loss, test_accuracy = model.evaluate(input_test, output_test, verbose=0)
print(f"Done training. Model Accuracy = {100*test_accuracy}%, Loss = {test_loss}")

# Convert output to probabilities
probability_model = tf.keras.Sequential([model, tf.keras.layers.Softmax()])

######## MAKE PREDICTIONS USING TEST DATA ########
showTestCases = str.upper(input('Show sample outputs from test data? Y/N: ')).strip()
if showTestCases == 'Y':
  predictions = probability_model.predict(input_test)
  numPredictions = int(input(f"Number of Test Cases (1-{len(input_test)}): "))
  selectedPredictions = np.floor(np.linspace(0, len(input_test)-1, numPredictions)).astype(int)
  for i in range(0, len(selectedPredictions)):
    predicted = predictions[selectedPredictions[i]]
    actual = output_test[selectedPredictions[i]]
    print(f"--------FINISHER {selectedPredictions[i]+1}--------")
    print("Expected: {:2.0f}% silver, {:2.0f}% bronze, {:2.0f}% no buckle".format(100*predicted[0], 100*predicted[1], 100*predicted[2]))
    print(f"Actual: {buckleNames[actual]}")

######## MAKE PREDICTIONS USING USER INPUT ########

predictRunner = False

predictRunner = True if str.upper(input('Predict buckle for specific athlete? Y/N: ').strip()) == 'Y' else False

while (predictRunner):
  # User inputs features in order: gender, age, min temp, max temp, aid stations
  inputFeatures = []
  inputFeatures.append(1.0 if str.upper(input("Gender Category (M/F): ")).strip() == 'M' else 0.0)
  inputFeatures.append(int(input("Age: ")))
  inputFeatures.append(float(input("Low Temperature (F): ")))
  inputFeatures.append(float(input("High Temperature (F): ")))
  for aid in range(0, len(aidStationNames)):
    inputFeatures.append(getHours(input(f"Split at {aidStationNames[aid]} (hh:mm:ss): ")))

  inputFeatures = np.array(inputFeatures).reshape(1, len(inputFeatures))

  # Predict
  prediction = probability_model.predict(inputFeatures)
  print(f"Based on provided input data, expected buckle is {str.upper(buckleNames[np.argmax(prediction)])}.")
  print("Probabilities: {:2.0f}% silver, {:2.0f}% bronze, {:2.0f}% no buckle".format(100*prediction[0][0], 100*prediction[0][1], 100*prediction[0][2]))
  predictRunner = True if str.upper(input('Predict another athlete? Y/N: ').strip()) == 'Y' else False